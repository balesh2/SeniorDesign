# Hephaestus Software
# Oregon State University - RockSat-X
# Amber Horvath, Helena Bales, Michael Humphrey

## Program Overview
Hephaestus is a rocketry payload made by Oregon State University for the RockSat-X program. The faculty advisor for this project is Nancy Squires. The involvement of twelve of the project contributors is part of the Senior Design classes. The Senior Design groups include two Mechanical Engineering groups, an Electrical Engineering group, and the Computer Science group. This repository is for project deliverables for the CS Senior Design class as well as any design documents, code, testing, data, and documentation generated by the Computer Science team throughout the 2016/2017 Senior Design year.

Participation and flight in the RockSat-X program is subject to revue and approval from the Colorado Space Grant Consortium. Pending this approval, the Hephaestus payload will fly in August of 2017.

## Mission Overview
The Oregon State University RockSat-X team will demonstrate that an autonomous robotic arm can locate predetermined targets around the payload under microgravity conditions by using precise movements. The technical actions performed by this demonstration will illustrate a proof of concept for creating assemblies, autonomous repairs, and performing experiments in space.

## Repository Contents
This section will describe the contents and structure of this repository.

### Deliverables
The deliverables directory shall contain all deliverables for the CS Senior Design course. These deliverables are broken up into the term and assignment subdirectories. Assignments will be added through June 2017, at which point the course will conclude.

### Design Documents
The Design Documents directory contains all design documents that we create. These shall be further organized by term and subject, pending need for organization. For the moment this shall be a place for any in progress, partial, or draft items.

### Photos
The Photos directory shall include all photo documentation for the project, including any graphics for promotional use (such as logos or flyers).

### Presentations
The Presentations directory shall include all presentations given by the CS team. This will include all presentations for RockSat-X program design reviews, presentations for promotional purposes, or for fundraising purposes.

### Testing
### Code
├── CSpace
│   ├── 0plot.png - a 3D plot of the configuration space for the poster
│   ├── CSpace\_Mapping
│   │   └── CSpace\_Mapping.ino - Code for the Arduino UNO set up for CSpace mapping
│   ├── a.out
│   ├── cspace - Binary representation of the configuration space generated by parser.cpp. One line of bin 37x37x37x37 array.
│   ├── cspacePlotData - Data used to generate the CSpace visualization for the poster.
│   ├── data.py - Python script to generate the CSpace viz
│   ├── parser.cpp - C++ program that parses the data from CSpace\_Mapping.ino stored in ./test1/data1 - compile as g++ ./parser.cpp
│   ├── pathing.cpp - C++ program that creates  the path through the cspace in ./cspace from each of the target points - compile as g++ ./pathing.cpp
│   └── test1
│       ├── data1 - The data from ../CSpace\_Mapping.ino
│       └── data2 - The data from ../CSpace\_Mapping.ino
├── Drivers
│   ├── Makefile
│   ├── RSXAVRD.c
│   ├── RSXAVRD.h
│   └── test.c
├── Hephaestus
│   ├── Hephaestus
│   │   ├── 00history.txt
│   │   ├── 00readme.txt
│   │   ├── Hephaestus.componentinfo.xml
│   │   ├── Hephaestus.cproj
│   │   ├── Makefile
│   │   ├── RSXAVRD.c
│   │   ├── RSXAVRD.d
│   │   ├── RSXAVRD.h
│   │   ├── RSXAVRD.o
│   │   ├── diskio.c
│   │   ├── diskio.d
│   │   ├── diskio.h
│   │   ├── diskio.o
│   │   ├── ff.c
│   │   ├── ff.d
│   │   ├── ff.h
│   │   ├── ff.o
│   │   ├── ffconf.h
│   │   ├── idle.c
│   │   ├── integer.h
│   │   ├── main-FAT.c
│   │   ├── main.c
│   │   ├── mmc\_avr.h
│   │   ├── mmc\_avr\_spi.c
│   │   ├── mmc\_avr\_spi.d
│   │   ├── mmc\_avr\_spi.o
│   │   ├── observation.c
│   │   ├── phases.h
│   │   ├── retract.c
│   │   ├── retract.h
│   │   ├── rtc.c
│   │   ├── rtc.h
│   │   ├── safety.c
│   │   ├── science.c - Science Mode - runs the motors along the path generated by pathing.cpp - compile using make science
│   │   ├── sd\_card\_test\ 2.bin.cpgz
│   │   ├── sd\_card\_test.bin
│   │   ├── sd\_card\_test.bin.cpgz
│   │   ├── sd\_card\_test.c
│   │   ├── sd\_card\_test.d
│   │   ├── sd\_card\_test.elf
│   │   ├── sd\_card\_test.hex
│   │   ├── sd\_card\_test.lst
│   │   ├── sd\_card\_test.map
│   │   ├── sd\_card\_test.o
│   │   ├── sd\_card\_test.srec
│   │   ├── sd\_card\_test\_eeprom.bin
│   │   ├── sd\_card\_test\_eeprom.hex
│   │   ├── sd\_card\_test\_eeprom.srec
│   │   ├── src
│   │   │   └── option
│   │   │       ├── cc932.c
│   │   │       ├── cc936.c
│   │   │       ├── cc949.c
│   │   │       ├── cc950.c
│   │   │       ├── ccsbcs.c
│   │   │       ├── syscall.c
│   │   │       └── unicode.c
│   │   ├── telemetry.c
│   │   ├── telemetry.h
│   │   ├── test.c
│   │   ├── test.d
│   │   ├── test.map
│   │   ├── test.o
│   │   ├── uart.h
│   │   └── xitoa.h
│   ├── Hephaestus.atsln
│   └── MotorTest
│       ├── Makefile
│       ├── MotorTest.componentinfo.xml
│       ├── MotorTest.cproj
│       ├── RSXAVRD.c
│       ├── RSXAVRD.d
│       ├── RSXAVRD.h
│       ├── RSXAVRD.o
│       └── main.c
└── SDRead
    ├── CreateFakeFile.py
    └── SDRead.py

## Instruction to Build

### Before you build
Before you can build the code for this project, make sure you have the avr-gcc compiler as well as an ATmega128 microchip and programmer. You can obtain a copy of the avr-gcc compiler from the [WinAVR suite](http://winavr.sourceforge.net/) for Windows, or by installing the `avr-libc`, `binutils-avr`, `gcc-avr`, and `avrdude` packages from your Linux OS's package repository. The ATmega128 chip can be purchased from [Microchip's website here](https://www.microchip.com/wwwproducts/en/ATMEGA128). Also, be sure to have a programming board for your ATmega128 chip, which can be obtained from the OSU TekBot store.

### Building
1. Navigate to the code/Hephaestus/Hephaestus directory.
2. Run `make all` to compile the code.
3. Run `make program` to program the microcontroller.
