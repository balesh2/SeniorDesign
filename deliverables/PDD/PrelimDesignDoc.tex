\documentclass[letterpaper,10pt]{article}

\usepackage{geometry}
\usepackage{hyperref}
\usepackage[nopostdot]{glossaries}
\usepackage[pdftex]{graphicx}
\usepackage{tikz}
\usepackage{wrapfig}
\geometry{textheight=8.5in, textwidth=6in}
\newenvironment{bottompar}{\par\vspace*{\fill}}{\clearpage}

\makeglossaries
\loadglsentries[main]{Glossary}

\title{Preliminary Design Document For RockSat-X Payload - Hephaestus}
\author{Helena~Bales, Amber~Horvath, and Michael~Humphrey\\ \\ CS461 - Fall 2016}

\parindent = 0.0 in
\parskip = 0.1 in

\begin{document}
\maketitle

\begin{abstract}
The \gls{osu} RockSat-X team shall be named Hephaestus.
The preliminary design of our project shall be outlined in this document.
The mission requires that the \gls{payload}, an autonomous robotic arm, perform a series of motions to locate predetermined targets.
The hardware shall be capable of performing the motions to reach the targets.
The software shall determine the targets and send the commands to the hardware to execute the motion.
The combination of the hardware controlled by the software shall demonstrate Hephaestus's ability to construct small parts on orbit.
This document will focus on the implementation of the software, but shall include necessary project context including hardware.
\end{abstract}

\begin{bottompar}
Approved By
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
Date \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ \\


Approved By
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
Date \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ \\


Approved By
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
Date \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ \\


Approved By
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
Date \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ \\
\end{bottompar}

\clearpage
\tableofcontents
\clearpage

\section{Introduction}
\subsection{Document Overview}
\subsubsection{Helena Bales}
\begin{enumerate}
\item{Target Generation}
\item{Arm Movement}
\item{Arm Position Tracking}
\end{enumerate}
\subsubsection{Amber Horvath}
\begin{enumerate}
\item{Emergency Payload Expulsion}
\item{Program Modes of Operation}
\item{Target Success Sensors}
\end{enumerate}
\subsubsection{Michael Humphrey}
\begin{enumerate}
\item{Telemetry}
\item{Video Camera}
\item{Data Visualization and Processing}
\end{enumerate}

\section{Technologies}
\subsection{Target Generation}
\subsubsection{Requirement Overview}
The software shall generate points to be used in testing the Hephaestus arm.
The points will constitute the total test of the arm, and should therefore include points
representative of standard and edge cases.
These points shall be used as targets for the arm body.

\subsubsection{Solution Design}
\textbf{The points shall be generated in 3-D polar form}, including an angle from normal, a radius, 
and a height. 
The angle shall be in the range of 0 and 359 degrees.
An angle of zero degrees shall be in the direction of payload deployment.
The radius shall be the distance from the arm's attachment to the base to the generated point.
The height of the point, for the purpose of target generation, shall be constant.
However the points will always be stored in a triple of angle from normal (\(\theta\)), radius (\(r\)), and height (\(h\)).

\subsection{Arm Movement}
\subsubsection{Requirement Overview}
The software shall control the movement of the arm body assembly. 
The position of the tip of the arm shall be tracked in the coordinate notation described in section 2.2 above.
The software shall rotate the arm body assembly in a full 360 degrees.
The software shall additionally control the movement the height of the arm body assembly.
The arm should descend and touch the baseplate of the payload at any rotation.

\subsubsection{Solution Design}
\textbf{The movement of the arm shall be generated by a custom system where the movement of the arm is 
generated based on the current position and the starting position.} 
The position of the tip of the arm shall be stored as decided from the list of solutions above. 
In the case of the selection of solution 3, the position will have an added height. 
The position shall be denoted as point \(p\) and shall be the location of the tip of the arm.
The arm shall generate a series of commands for the motors to perform to go from \(p\) to the target, 
\(t_{n}\) where \(t_{n}\) is the n-th target.
The movement of the arm shall be constrained by the heights of the arm so that it will not collide with 
the top or base plates.

\subsection{Arm Position Tracking}
\subsubsection{Requirement Overview}
The position of the arm shall be tracked using the same coordinate system described in the Target Generation requirement.
The position of the arm shall be calculated using the known start position and the rotation of the motors.
\subsubsection{Solution Design}
\textbf{The position of the arm shall be tracked using the motor movement to calculate \(p\) and 
\(p_{m2}\).}
The initial position of the arm shall be defined in advance, and a sensor will be placed at that location. 
From there, the position will be tracked from the movement of the motors.
The arm will recalibrate by returning to the initial position in order for the error to not increase over
 time.
The position of the arm shall be denoted \(p\), the location of the tip of the arm.
From the coordinate \(p\), the location of \(p_{m2}\), the center of the middle joint of the arm, will be
 calculated. The height of \(p_{m2}\) will be calculated from the triangle made of the two arm sections, 
L1 and L2, and the radius of point \(p\). From there the radius of the point \(p_{m2}\) can be calculated
 using the triangle of L1, \(h_{m2}\) and the radius of m2. Finally, the \(\sigma\) of \(p_{m2}\) shall 
be the same as that of \(p\).
Using this method will allow for the extra condition that point \(p_{m2}\) should never exceed the height
 of the can.
Constrain rotation to not go all the way around.

\subsection{Emergency Payload Expulsion}
\subsubsection{Requirement Overview}
The software shall eject the arm upon system failure. 
System failure in this case is defined as the arm becoming lodged or stuck in a state where it is unable to retract.
The software will enter Safety mode (defined in section 2.5.2) and attempt to retract the arm. If it is unable to complete this step,
 the system will continue attempting to eject the arm until ejection is completed
\subsubsection{Solution Design}
Upon entering the Shutdown state, the system should succeed in closing the arm, the Arm Assembly Body should be retracted, 
and the \gls{OBC} should be powered off. A time shall be implemented to detect whether the arm is stuck. The timer shall determine this by 
checking if a certain amount of time has passed between the last arm movement and the last request for an arm movement. 
If arm movement requests are not being met by arm movements, and the system stalls past a certain amount of time, the system should 
send a signal to enter the Safety state so that the arm can be ejected, as it is most likely caught in a bad extended position.
The system shall determine shutdown was not completed correctly (as seen in state 7 defined in section 2.5.2) by determining that one 
of these requirements was not met.
The system shall determine the arm is not contracting properly by the amount of torque that the motor is applying, as failure to 
contract will require more torque. The system will fire an interrupt signal from the AVR interrupt library, notifying the system to 
transition to Safety mode. 
Safety mode will attempt to contract the arm once more by calling the arm movement function. The arm movement function will take a 
coordinate to move the end of the arm to. The arm is equipped with sensors that can determine if the arm is folded or not
so if the sensors determine that the arm is folded, then safe shutdown should be possible.
The emergency retracting operation is completed by turning off all the motors in the 
in the arm except for the motor pushing the whole metal plate the arm is attached to in and out of the payload.
With those motors turned off, the joints of the arm will be flimsy and can be pulled into the payload by retracting the metal plate.
In the case of contracting the arm, the tip should point inwards to the center of the canister.
If it is unable to do so, it shall continue attempting to eject. 
The system shall initiate the arm ejection sequence by turning on the motor in control of ejecting part of the arm and turning off all
other motors. 
The system shall also clean up any memory leaks and ensure all telemetry ports are closed upon sending the data that an 
emergency ejection was required. In the post-mortem analysis, information regarding the arm's expulsion will be useful. The system
shall, upon receiving a signal that ejection is required, send a log description of the current polar coordinates of the arm, the time 
elapsed since last arm movement request, and what state the system was in prior to being sent to the Safety state. The system will 
continue attempting to eject the arm until the system detects that the metal plate has successfully returned into the payload. 
The system shall determine this by a pin being set from low to high upon entry into the payload. 
If the arm is unable to be ejected safely, the arm will be stuck outside the canister and the mission shall be counted
as a failure.

\subsection{Program Modes of Operation}
\subsubsection{Requirement Overview}
The software shall have the Modes of Operation necessary to insure the mission success.
The software shall first deploy the payload, then the arm. Next the software shall activate the 
camera and perform a video sweep. The software shall then perform the science experiment.
If the experiment fails, it shall return to observation mode.
If observation mode fails, it shall return to idle.
Once the experiment time has been exhausted, the payload shall shut down.
If it shuts down correctly, everything will poweroff. If not, the payload shall attempt to retract 
again, or expel the payload from the rocket.
\subsubsection{Solution Design}
\input{state_diagram}
\begin{center}
Diagram of software states of operation and transition between states [2].

Transitions between states occur as numbered:

\begin{enumerate}
\item{\textbf{Appogee is reached.} The software shall activate when the power line goes to high at 28V. Observation mode shall be 
triggered when the \gls{OBC} turns on. Observation mode will collect a sweep of the payload with the camera. This mode will ensure that the 
camera is operational during the more crticial parts of the mission.}
\item{\textbf{Error: Return to Idle.} If an error is encountered in entering Observation mode, the software shall fallback to Idle 
mode and retry. An error may occur if the payload fails to deploy correctly or if the camera fails to turn on. The system shall send
a signal using the AVR interrupt library if the arm is not fully extended, as the arm is equipped with sensors to determine whether
it is extended or folded. If the camera fails to turn on, the system shall be notified as the telemetry line will be sending empty
data.}
\item{\textbf{Payload Assembly and Camera have been deployed.} The software shall enter Science mode once the payload assembly and arm
 have deployed and the camera has performed an observation sweep. Science mode will consist of the arm touching the sensors in 
 the payload canister, and collecting data via the telemetry line. The whole mode shall be captured with the camera.}
\item{\textbf{Error: Return to Observation} The software shall return to observation mode if any error occurs in Science mode. An error may occur in Science mode if the arm fails to operate correctly and must return to default position. An error may also occur if the camera stops working. The system shall know if the arm fails as a timer can keep track of the time between an arm movement request
and the arm actually completing the movement request. If too much time has elapsed between the request and the movement, the arm may
be stuck. If the telemetry line stops receiving data from the camera, then the camera has stopped working and the system shall be 
notified via an interrupt.}
\item{\textbf{Timer switches to end appogee period.} Once the time period for observation has ended, the timer line will go to low and trigger to Shutdown state. This state can be reached from either Observation or Science mode.}
\item{\textbf{Accept: Shutdown correctly} If Shutdown occurs correctly, the arm should be closed, the Arm Assembly Body should be retracted, and the \gls{OBC} should be powered off. The arm will be have sensors to detect whether its closed or not, which can also
be used to know whether it has been retracted into the body. Once the system has determined that this criteria has been met, it
will power off.}
\item{\textbf{Error: Shutdown not completed successfully.} If an error occurs in the shutdown sequence, the software shall enter Safety mode. An error that could occur is the arm failing to close, the Body failing to retract, or the \gls{OBC} not powering off. All 
these situations except for the \gls{OBC} not powering off are handled through Safety mode.}
\item{\textbf{Payload is Shutdown correctly.} If the payload is Shutdown through Safety mode, shutdown can be completed. In Safety mode, the payload was either shut down correctly, retracted fully into the can with the arm open, or the arm was expelled safely from the rocket. The shutdown sequence consists of the arm closing, the Body retracting, and the \gls{OBC} being powered off.}
\item{\textbf{Error: Payload is still deployed.} The software shall remain in Safety mode until the payload is either retracted correctly, retracted fully with the arm in the open position, or ejected safely from the rocket. Safety mode shall first try to correctly retract the arm, then retract with the arm open, then repeat attempting ejection until the payload is ejected.}
\end{enumerate}
\end{center}

\subsection{Target Success Sensors}
\subsubsection{Requirement Overview}
The software shall know whether or not the arm succeeded in touching the targets generated, as described in section 2.1. The sensors
shall report back whether or not contact was made. This data can be used in post-mortem analysis to determine whether
certain targets were faulty or whether the range of motion on the arm was faulty.
\subsubsection{Solution Design}
The payload shall be equipped with pre-placed sensors that the arm shall make contact with. The arm shall have generated targets
as described in section 2.1. These coordinates shall be stored within the system and used as inputs for the function controlling
the arms' movements, with the target position being where the tip of the arm should be located. The arm shall exert force to touch
the sensor, and the sensor shall go high if contact is made. The sensors high or low signal shall be sent via the telemetry
line. If the arm gets stuck during this process, it will enter Safety mode, as described in section 2.5. The telemetry data shall
later be visualized using Python's UI package, TK. 

\subsection{Telemetry}
\subsubsection{Requirement Overview}
The software shall report via telemetry all sensor data.

\subsubsection{Solution Design}
The telemetry component is responsible for collecting and sending data through the
telemetry ports on the \gls{payload}.

\subsection{Video Handling}
\subsubsection{Requirement Overview}
The software shall be responsible for controlling the camera output.

\subsubsection{Solution Design}
The video handling component shall be responsible for capturing video footage of
the experiment as it runs, and storing the footage for playback at a later time.
The hardware of this component includes a camera and a device that can read
and write to an SD card.

The camera shall be a GoPro Hero Black.
The camera shall be configured in One Button Mode, which means the  camera will
automatically start recording on power on and stop recording on power off. 

Because heat generated from reentry and water from the ocean landing both have
a high likelihood of destroying the camera, the footage from the camera shall be
stored on an SD card in external SD card read/write device. 
The external SD card device shall be contained in a heat and water resistant enclosure.
The enclosure for the SD card device shall be designed and created by the Hephaestus Structures team.
The camera shall write the footage to the external SD card device automatically,
without any intervention from the payload software. 

When the \gls{ter} line activates, signaling the beginning of the experiment,
the software shall enable power to the camera.
The camera shall begin recording footage immediately upon receiving power. 
Upon completion of the experiment (successful or otherwise) the software shall
power off the camera. 


\subsection{Data Visualization and Processing}
\subsubsection{Requirement Overview}
The data visualization and processing component shall provide visualizations
for the collected data.
This component shall be able to show whether the mission success criteria have
been met or not.
If the mission success criteria have not been met, this component shall show how
and why they have not been met.

\subsubsection{Solution Design}
The component shall have a \gls{gui} written in Tkinter with graphs generated by
\gls{matplotlib}.
The \gls{gui} shall consist of two graphs and a table.
Each graph shall be a \gls{plot} with analog data collected from each of two temperature sensors.
The data from the temperature sensors shall be graphed with respect to time from
\gls{apogee} and actual temperature, if such a value can be determined.
In the absense of a method to reliably determine actual temperature from the raw
sensor data, then the data shall be graphed with respect to the raw value received
from the sensor, with the graph scaled such that the lowest value recorded shall be
the minimum y value, and the highest recorded value recorded shall be the maximum y value.
The table shall consist of the name of each of a series of tests,
the result of that respective test, and the time that test was completed.
A result shall be either ``passed'', ``failed'', or ``not completed''.
A result of ``passed'' shall be colored in green.
A result of ``failed'' shall be colored in red.
A result of ``not completed'' shall be colored in gray.
If the result of a test is ``not completed'', then the time of completion for that test
may be omitted.
There shall be a predetermined number of tests.
The number and nature of tests has yet to be determined.
The tests shall be designed as a joint effort between the Hephaestus Structures,
Robotics, Electrical, and Software teams.

It has not been determined if the data shall be processed in a real-time manner
(i.e. the telemetry data is received by the data processing software as the
spacecraft software sends it, given a delay) or if the telemetry data will be provided
by \gls{wff} after the completion of the mission.

If the data will be streamed in a real-time manner, then additionally this component shall:
\begin{itemize}
\item Update the \gls{gui} as soon as the data is received.
\item Continue to process the incoming data, even if an error occurs.
\item Store the incoming data in a file to be reviewed and \gls{replay}ed later.
\item Load data from a file and \gls{replay} the telemetry data.
\item Load data from a file and display a summary of all test results and
temperature data.
\end{itemize}

\section{Conclusion}
This concludes the preliminary design of our project. Further questions or concerns can be addressed to the authors of this document.
This document may be subject to changes in the future as more design constraints are found, or designs are found to not work the way
they were intended upon the creation of this document. The document shall be updated accordingly to account for these changes.


\printglossary[numberedsection]

\section{Appendix}
\input{Appendix}


\end{document}
